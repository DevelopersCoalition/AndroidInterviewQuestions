# Kotlin questions

## Q1. Что такое inline функции, в чем их преимущество?

В Kotlin есть два типа функций: обычные и встроенные. Обычные функции похожи на функции в других языках программирования. Но встроенные функции имеют модификатор **inline**. Это позволяет компилятору подставить тело функции прямо в место её вызова.

Как работают **inline** функции?

Использование анонимных функций (лямбда-выражений) в Kotlin приводит к дополнительным затратам памяти. При использовании лямбда-выражения создается объект FunctionN (где N — количество параметров в лямбда-выражении), который содержит ссылку на само лямбда-выражение и может содержать захваченные переменные. При передаче лямбда-выражения в качестве параметра метода также создается новый объект FunctionN, что приводит к дополнительным затратам памяти.

Поэтому, чтобы избежать создания дополнительных объектов при передаче лямбда-выражений в функцию в качестве параметра, можно использовать встраивание (inline). Ключевое слово inline позволяет компилятору подставить тело функции непосредственно в место её вызова, вместо того, чтобы создавать объекты функций. Таким образом можно уменьшить затраты на создание объектов и улучшить производительность приложения.

Пример синтаксиса inline-функций с лямбдой:

```
inline fun functionName(parameter1: Type1, parameter2: Type2, ..., parameterN: TypeN, block: () -> Unit): ReturnType {
    // function body
}
```

Модификатор **inline** влияет и на функцию, и на лямбду, переданную ей: они обе будут встроены в место вызова.

## Q2. Модификатор noinline

Если же вы хотите, чтобы некоторые лямбды, переданные inline-функции, не были встроены, то отметьте их модификатором **noinline**.

```
inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {
    // ...
}
```

Разница между ними в том, что встраиваемая лямбда может быть вызвана только внутри inline-функции, либо может быть передана в качестве встраиваемого аргумента. В то время как с noinline-функциями можно работать без ограничений: **хранить внутри полей, передавать куда-либо и т.д.**

## Q3. Что такое нелокальный return?

В Котлин **non-local return** — это механизм, который позволяет выйти из внешней функции или лямбда-выражения и вернуться к вызывающему коду, обходя оставшуюся часть текущей функции или лямбда-выражения. Он работает по-разному в зависимости от того, является ли функция **inline** или **не-inline**.

**В не-inline функциях:**

- Если внутри функции есть лямбда-выражение, non-local return из лямбда-выражения может привести к нелокальному завершению внешней функции.
- Для использования non-local return внутри лямбда-выражения в не-inline функции, необходимо использовать метку (label) и оператор `return@label`.

**В inline-функциях:**

- В inline-функциях, лямбда-выражения становятся частью кода функции и имеют локальный контроль над потоком управления.
- Оператор return внутри лямбда-выражения в inline-функции приведет только к завершению самого лямбда-выражения, не влияя на внешнюю функцию.

## Q4. Как работает модификатор crossinline?

**crossinline** — ключевое слово, которое используется для указания, что лямбда-выражение **не может содержать нелокальных** `return`, даже если оно передано в inline-функцию.

Когда мы передаем лямбда-выражение в функцию в качестве параметра, мы можем использовать оператор `return` внутри лямбды, чтобы выйти из цикла или функции, в которой вызывается лямбда. Однако, если мы передаем лямбда-выражение в inline-функцию, код лямбда-выражения может быть вставлен прямо в место вызова функции. В этом случае, если в лямбде используется оператор return, это может привести к выходу из внешней функции, что не всегда желательно.

## Q5. Когда нужно использовать crossinline, а когда noinline?

Модификаторы `crossinline` и `noinline` используются для управления поведением лямбда-выражений, переданных в качестве параметров функций. Они позволяют указывать, может ли лямбда-выражение содержать операторы `return`.

- Модификатор `crossinline` используется для указания того, что лямбда-выражение **не может содержать операторы** `return`, даже если функция, принимающая лямбда-выражение, инлайновая.

- Модификатор `noinline`, с другой стороны, указывает на то, что лямбда-выражение может быть сохранено как объект функции, а не выполнено внутри вызывающей функции. Это может быть полезно в случае, когда вы хотите использовать лямбда-выражение где-то ещё, например, как параметр для другой функции.

**ВЫВОД:** `crossinline` должен использоваться только тогда, когда вы уверены в том, что оператор `return` **не будет использоваться** внутри лямбда-выражения. Если лямбда-выражение должно содержать оператор `return`, то следует использовать ключевое слово `noinline` вместо `crossinline`.
