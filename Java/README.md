# Java questions

## Q1. Данные передаются по ссылке или по значению?

При передаче примитива копируется значение, при передачи объектов (ссылочный тип) копируется ссылка на объект.
Таким образом, мы можем сказать, что Java — это язык строгой передачи по значению _(pass-by-value)_.

## Q2. В чем разница между `import` и `static import`

`import java.util.ArrayList` — специфичный класс

`import java.util.*` — все классы в пакете

`import com.baeldung.A.*` — вложенный класс

`import static java.util.Collections.EMPTY_LIST` — импорт статических членов класса

## Q3. Какие модификаторы доступа доступны в Java и их назначение

* `private`
* `protected`
* `public`
* `default (package)` модификатор не прописывается вообще, при этом класс или его члены будут доступны только внутри пакета

## Q4. Другие модификаторы и их назначение

* `static` Для полей и методов. Статические поля или методы являются членами класса, а нестатические — членами объекта. Членам класса не нужен экземпляр для вызова. Они вызываются с именем класса вместо имени ссылки на объект.
* `final` Для полей, методов, классов. Когда `final` используется для **поля**, это означает, что ссылка на поле не может быть изменена. Когда `final` применяется к **классу** или **методу**, это гарантирует, что этот класс или метод не может быть расширен или переопределен.
* `abstract` Для классов и метдов. Когда **классы** абстрактны, они не могут быть созданы, они предназначены для подкласса. Когда **методы** являются абстрактными, они остаются без реализации и могут быть переопределены в подклассах.
* `synchronized` Мы можем использовать его с **экземпляром**, а также со **статическими методами** и **блоками кода**. Когда мы используем это ключевое слово, мы заставляем Java использовать **monitor lock** для обеспечения синхронизации данного фрагмента кода.
* `volatile` Мы можем использовать его только вместе с **полями экземпляра**. Он объявляет, что значение поля должно быть прочитано и записано в **main memory**, минуя кеш процессора. Все операции чтения и записи для `volatile`-переменной являются атомарными.

## Q5. В чем разница между `JDK`, `JRE`, `JVM`

`JDK` означает `Java Development Kit`, набор инструментов, необходимых разработчикам для написания приложений на Java. Существует три типа сред JDK:
* Standard Edition
* Enterprise Edition
* Micro Edition

В JDK включено множество инструментов, которые помогают программистам писать, отлаживать или поддерживать приложения. Наиболее популярными из них являются компилятор `javac`, интерпретатор `java`, архиватор `jar` и генератор документации `javadoc`.

`JRE` означает `Java Runtime Environment`. Это часть JDK, но он содержит минимальную функциональность для запуска приложений Java. Он состоит из виртуальной машины Java, основных классов и вспомогательных файлов. Например, у него нет компилятора.

`JVM` означает `Java Virtual Machine`. Представляет собой виртуальную машину, способную запускать программы, скомпилированные в байт-код. Наиболее важной функцией JVM является предоставление пользователям возможности развертывать одно и то же Java-приложение в разных операционных системах и средах, не беспокоясь о том, что находится под ним.

## Q6. В чем разница между `Stack` и `Heap`

Есть две части памяти, где все переменные и объекты хранятся в JVM. 

Стек — это место, где JVM резервирует блоки для локальных переменных и дополнительных данных. Стек представляет собой структуру LIFO. Это означает, что при каждом вызове метода новый блок резервируется для локальных переменных и ссылок на объекты. Каждый вызов нового метода резервирует следующий блок. Когда методы завершают свое выполнение, блоки освобождаются в порядке, обратном их запуску.

**Каждый новый поток имеет свой собственный стек**

Когда стек заполнен, JVM выдаст ошибку `StackOverflowError`. Каждый новый объект создается в куче Java, которая используется для динамического распределения. Есть сборщик мусора, который отвечает за стирание неиспользуемых объектов, которые делятся на молодые и старые пространства. Доступ памяти к куче медленнее, чем доступ к стеку. JVM выдает ошибку `OutOfMemoryError`, когда куча заполнена.

## Q7. В чем разница между интерфейсами `Comparable` и `Comparator`

```java
public interface Comparable<T> {
    int compareTo(T var1);
}
```
Он может возвращать три значения: -1, 0 и 1, что означает, что этот объект меньше, равен или больше сравниваемого объекта.
```java
public class Player implements Comparable<Player> {
    @Override
    public int compareTo(Player otherPlayer) {
        return Integer.compare(getRanking(), otherPlayer.getRanking());
    }
}
```

`Comparator` полезен, когда мы используем сторонний класс, который не реализует интерфейс `Comparable`.
```java
public class PlayerAgeComparator implements Comparator<Player> {
    @Override
    public int compare(Player firstPlayer, Player secondPlayer) {
       return Integer.compare(firstPlayer.getAge(), secondPlayer.getAge());
    }
}
```

```java
PlayerRankingComparator playerComparator = new PlayerRankingComparator();
Collections.sort(footballTeam, playerComparator);
```
## Q8. `void` vs `Void`

`Void` – класс-заполнитель, который можно использовать, например, при работе с дженериками. Класс Void не может быть ни создан, ни расширен.

## Q9. Методы класса `Object`

* `clone()` – returns a copy of this object
* `equals()` – returns true when this object is equal to the object passed as a parameter
* `finalize()` – сборщик мусора вызывает этот метод во время очистки памяти
* `getClass()` – returns the runtime class of this object
* `hashCode()` – returns a hash code of this object. Мы должны знать, что это должно быть согласовано с методом `equals()`
* `notify()` – отправляет уведомление одному потоку, ожидающему монитор объекта
* `notifyAll()` – отправляет уведомление всем потокам, ожидающим монитор объекта
* `toString()` – returns a string representation of this object
* `wait()` – существует три перегруженных версии этого метода. Это заставляет текущий поток ждать указанное количество времени, пока другой поток не вызовет `notify()` или `notifyAll()` для этого объекта

## Q10. Особенности перечислений

```java
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY 
}
```
Для перебора всех констант мы можем использовать метод `static values()`. Более того, перечисления позволяют нам определять члены, такие как свойства и методы. Хотя это особый тип класса, мы не можем создать подкласс. Однако перечисление может реализовывать интерфейс. Еще одним интересным преимуществом Enum является то, что они потокобезопасны и поэтому широко используются как синглтоны.

## Q11. Что такое `JAR`

`JAR` означает `Java archive`. Это архивный файл, упакованный в формате `ZIP`. Мы можем использовать его для включения файлов классов и вспомогательных ресурсов, необходимых для приложений. Он имеет много особенностей:

* `Безопасность` — мы можем подписывать файлы JAR цифровой подписью
* `Сжатие` — при использовании JAR мы можем сжимать файлы для эффективного хранения
* `Переносимость` — мы можем использовать один и тот же файл JAR на разных платформах
* `Управление версиями` — файлы JAR могут содержать метаданные о содержащихся в них файлах
* `Запечатывание` — мы можем запечатать пакет в файле JAR. Это означает, что все классы из одного пакета должны быть включены в один и тот же файл JAR
* `Расширения` — мы можем использовать формат файла JAR для упаковки модулей или расширений для существующего программного обеспечения

## Q12. Преобразование типов

Мы можем выполнить преобразование вверх `upcasting`, которое приводит объект к супертипу, или преобразование вниз `downcasting`, которое приводит объект к подтипу.

`Upcasting` очень прост, так как мы всегда можем это сделать. Например, мы можем преобразовать экземпляр String в тип Object:
```java
Object str = "string";
```

`Downcasting` Это не так безопасно, как `upcasting`, поскольку включает проверку типа.
```java
Object o = "string";
String str = (String) o; // it's ok

Object o2 = new Object();
String str2 = (String) o2; // ClassCastException will be thrown

if (o2 instanceof String) { // returns false
    String str3 = (String) o2;
}
```

## Q13. Почему `String` является неизменяемым `immutable` классом?

Объекты String обрабатываются JVM не так, как другие объекты. дно отличие состоит в том, что объекты String неизменяемы. Это означает, что мы не можем изменить их после того, как мы их создали. Причины:

* Они хранятся в пуле строк, который является специальной частью памяти кучи. Он отвечает за экономию места.
* Неизменность класса String гарантирует, что его хэш-код не изменится. В связи с этим строки можно эффективно использовать в качестве ключей при хешировании коллекций. Мы можем быть уверены, что не перезапишем данные из-за изменения хэш-кодов.
* Их можно безопасно использовать в нескольких потоках. Ни один поток не может изменить значение объекта String, поэтому мы бесплатно обеспечиваем потокобезопасность.
* Строки неизменяемы, чтобы избежать серьезных проблем с безопасностью. Конфиденциальные данные, такие как пароли, могут быть изменены ненадежным источником или другим потоком.

## Q14. `Dynamic binding` vs `Static binding`

`Связывание` в Java — это процесс связывания вызова метода с соответствующим телом метода. В Java можно выделить два типа связывания: `статическое` и `динамическое`.
Основное различие между статическим связыанием и динамическим связыванием заключается в том, что статическое связывание выполняется во время компиляции, а динамическое — во время выполнения.

`Статическое связывание` отвечает за разрешение `private`, `static`, `final` методов и переменных и за перегрузку методов (статический полиморфизм).

`Динамическое связывание` использует информацию об объекте. Оно отвечает за разрешение виртуальных и переопределенных методов (динамический полиморфизм).

## Q15. Что такое `JIT`

`JIT` означает `Just in time`. Это компонент `JRE`, который работает во время выполнения и повышает производительность приложения. В частности, это компилятор, который запускается сразу после запуска программы. Это отличается от обычного компилятора Java, который компилирует код задолго до запуска приложения. JIT может ускорить работу приложения разными способами. Например, компилятор JIT отвечает за компиляцию байт-кода в нативные инструкции на лету для повышения производительности. Кроме того, он может оптимизировать код для целевого процессора и операционной системы. Кроме того, он имеет доступ ко многим статистическим данным времени выполнения, которые можно использовать для перекомпиляции для достижения оптимальной производительности. При этом он также может выполнять некоторую глобальную оптимизацию кода или переупорядочивать код для лучшего использования кеша.

## Q16. Рефлексия

`Отражение` — это механизм языка Java, который позволяет программистам проверять или изменять внутреннее состояние программы (свойства, методы, классы и т. д.) во время выполнения. При использовании этой функции мы можем получить доступ ко всем возможным полям, методам, конструкторам, включенным в определение класса. Мы можем получить к ним доступ независимо от их модификатора доступа. Стоит знать, что есть возможность ограничить доступ через отражение. Для этого мы можем использовать диспетчер безопасности Java и файл политики безопасности Java. Они позволяют нам предоставлять разрешения классам. При работе с модулями начиная с Java 9 мы должны знать, что по умолчанию мы не можем использовать отражение для классов, импортированных из другого модуля. Чтобы разрешить другим классам использовать отражение для доступа к закрытым членам пакета, мы должны предоставить разрешение «Reflection».

## Q17. Что такое `Classloader`

`Загрузчик классов` — один из важнейших компонентов Java. Это часть JRE. Проще говоря, загрузчик классов отвечает за загрузку классов в JVM. Мы можем выделить три типа загрузчиков классов:

* **Bootstrap classloader** — он загружает основные классы Java. Они расположены в каталоге <JAVA_HOME>/jre/lib
* **Extension classloader** — он загружает классы, расположенные в <JAVA_HOME>/jre/lib/ext или по пути, определенному свойством java.ext.dirs
* **System  classloader** — он загружает классы в путь к классам нашего приложения

Загрузчик классов загружает классы «по требованию». Это означает, что классы загружаются после их вызова программой. Более того, загрузчик классов может загрузить класс с заданным именем только один раз. Однако если один и тот же класс загружается двумя разными загрузчиками классов, эти классы не проходят проверку на равенство.

## Q18. `Static` vs `Dynamic Class Loading`

`Статическая загрузка` классов происходит, когда у нас есть исходные классы, доступные во время компиляции. Мы можем использовать их, создавая экземпляры объекта с ключевым словом `new`.
`Динамическая загрузка` классов относится к ситуации, когда мы не можем предоставить определение класса во время компиляции. Тем не менее, мы можем сделать это во время выполнения. Чтобы создать экземпляр класса, мы должны использовать метод `Class.forName()`:
```java
Class.forName("oracle.jdbc.driver.OracleDriver")
```

## Q19. Интерфейс `Serializable`

Мы можем использовать интерфейс `Serializable`, чтобы обеспечить сериализуемость класса, используя Java Serialization API.
`Сериализация` — это механизм сохранения состояния объекта в виде последовательности байтов, а `десериализация` — это механизм восстановления состояния объекта из последовательности байтов.

Мы должны знать, что подтипы сериализуемых классов также сериализуемы. Однако, если мы хотим сделать класс сериализуемым, но его супертип несериализуемым, мы должны сделать две вещи:
* реализовать сериализуемый интерфейс
* убедиться, что в суперклассе присутствует конструктор без параметров

## Q20. Деструктор [которого нет]

В Java сборщик мусора автоматически удаляет неиспользуемые объекты, чтобы освободить память. Разработчикам не нужно помечать объекты для удаления, что чревато ошибками. Так что разумно, что в Java нет доступных деструкторов.

Если объекты содержат открытые сокеты, открытые файлы или соединения с базой данных, сборщик мусора не сможет восстановить эти ресурсы.

Мы можем освободить ресурсы в методе `close` и использовать синтаксис `try-finally` для последующего вызова метода до `Java 7`, например, в классах ввода-вывода `FileInputStream` и `FileOutputStream`.
Начиная с `Java 7`, мы можем реализовать интерфейс `AutoCloseable` и использовать оператор `try-with-resources` для написания более короткого и чистого кода.

Но возможно, что пользователи API забывают вызвать метод `close`, поэтому метод `finalize` и класс `Cleaner` появляются в качестве подстраховки. Но они не эквивалентны деструктору.

Нет гарантии, что и метод `finalize`, и класс `Cleaner` будут выполняться быстро. У них даже нет возможности запуститься до выхода JVM. Хотя мы могли бы вызвать `System.runFinalization`, чтобы предложить JVM запустить методы финализации любых объектов, ожидающих финализации, это все равно недетерминировано. Кроме того, метод `finalize` может вызвать проблемы с производительностью, взаимоблокировки и т. д.

Начиная с `Java 9`, вместо метода `finalize` добавлен класс `Cleaner` из-за его недостатков. В результате мы лучше контролируем поток, выполняющий действия по очистке. Но спецификация Java указывает, что поведение очистителей во время `System.exit` зависит от реализации, и Java не дает никаких гарантий, будут ли вызываться действия очистки или нет.
