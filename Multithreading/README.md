# Multithreading questions

## Q1. Что такое многопоточность?

Перед тем как рассмотреть многопоточность в мобильной разработке, важно понимать, что такое многопоточность вообще. Многопоточность — возможность программы выполнять несколько задач одновременно в рамках одного процесса. Это позволяет эффективно использовать вычислительные ресурсы компьютера или мобильного устройства и повышать производительность приложения. В контексте мобильной разработки многопоточность может быть особенно полезна, например при загрузке данных из cети, обработке графики или выполнении других трудоемких задач.
В процессе разработки Android-приложения любые операции, связанные с походом в cеть, или операции обращения к локальной базе данных — другими словами, операции ввода-вывода — должны осуществляться в фоновом потоке.

## Q2. Что такое CoroutineScope?

CoroutineScope — это основной компонент для управления корутинами в Kotlin. Он предоставляет API для запуска и отмены корутин и позволяет определять, на каком потоке должны выполняться операции. CoroutineScope также позволяет управлять жизненным циклом корутин и предотвращает утечки памяти.
CoroutineScope — это интерфейс, который предоставляет функции для запуска и управления корутинами. Корутины запускаются внутри CoroutineScope, который определяет их жизненный цикл и контекст выполнения.

## Q3. Что такое GlobalScope?

GlobalScope — это глобальный CoroutineScope, который может быть использован для запуска корутин в приложении.
Он не связан с жизненным циклом компонентов Android и продолжает выполнение корутин, даже если активность или фрагмент были уничтожены.
Однако GlobalScope также имеет свои опасности, так как он не ограничен жизненным циклом и может привести к утечкам памяти, если корутины не будут явно отменены или завершены.

## Q4. Что такое ViewModelScope?

viewModelScope — это CoroutineScope, связанный с жизненным циклом ViewModel. Он автоматически отменяет все связанные с ним корутины при уничтожении ViewModel.

## Q5. Что такое LifecycleScope?

lifecycleScope является удобным способом создания CoroutineScope, связанного с жизненным циклом компонента LifecycleOwner (например фрагмента или активности).
Преимуществом использования lifecycleScope является автоматическая отмена корутин. Корутины, запущенные в lifecycleScope, автоматически отменяются при уничтожении фрагмента или активности. Вам не нужно беспокоиться о явной отмене корутин: это происходит автоматически.

## Q6. Что такое LifecycleScope?

Ключевое слово suspend в Kotlin используется для обозначения функций, которые приостанавливают выполнение, но не блокируют поток выполнения. В контексте Kotlin Coroutines это означает, что функции с пометкой suspend могут быть приостановлены в процессе своего выполнения и возобновлены позже без блокировки основного потока выполнения.

Функции, помеченные как suspend, могут выполнять длительные операции ввода-вывода или другие блокирующие операции, не блокируя при этом основной поток выполнения. Вместо этого они могут приостанавливать свое выполнение и дать возможность другим сопрограммам его продолжить.

Функции с ключевым словом suspend могут быть вызваны только из корутин или других функций с ключевым словом suspend. Это делает код более безопасным и позволяет избежать проблем, связанных с блокировкой потоков.

## Q7. Что такое Continuation?

В качестве примера используем корутину:

```
launch {
    val data = fetchUsers() //suspend function

    println(data.toString())
}
```

Когда мы пишем код на Kotlin с использованием сопрограмм (корутин), этот код будет преобразован в java-классы при компиляции. Корутины не являются чем-то магическим, а просто абстракцией, которая реализована внутри этих классов.

Одной из ключевых составляющих корутин является ключевое слово suspend. Оно позволяет функции приостанавливать свое выполнение без блокировки потока, в котором она вызывается. Вместо этого функция будет выполняться в отдельном потоке, позволяя другому коду продолжать работу. Когда функция завершит свою работу, она возобновит выполнение кода, и функция, которая вызвала suspend-функцию, продолжит свое выполнение.

Когда kotlin-код преобразуется в java-код, для каждой корутины будет создан соответствующий java-класс, называемый Continuation. Этот класс содержит всю логику приостановки и возобновления выполнения корутины. Внутри Continuation используется механизм сохранения состояния и передачи управления между выполнением suspend-функций.

Для лучшего понимания механизма работы корутин и suspend-функций мы начнем с упрощенной версии Continuation, из которой исключим множество деталей, чтобы постепенно добавить их и получить более полный и оригинальный код. Это поможет нам разобраться в принципах работы корутин и понять, что под капотом происходит обычный код на Java.

Основная задача Continuation — сделать так, чтобы println был выполнен только после того, как функция fetchUsers завершит загрузку пользователей в фоновом потоке. Обычно в Java в таких случаях используется колбэк, но Continuation идет другим путем. Код в методе invokeSuspend делится свитчем на две части. И добавляется переменная label.

```
class GeneratedContinuationClass extends SuspendLambda {

    List<User> users;

    int label;

    void invokeSuspend() {
    switch (label) {
        case 0: {
	label = 1;
            users = fetchUsers(); // suspend function
            return;
        }
        case 1: {
            println(users.toString());
            return;
        }
    }

}
```

Suspend-функция, в нашем случае fetchUsers, поделит выполнение кода на две части. Код, который находится в ней и перед вызовом этой функции, будет относиться к первой части, в то время как код, который следует после вызова функции, будет относиться ко второй части.

В зависимости от значения переменной label, переданной в метод invokeSuspend, будет выполнена соответствующая часть кода. Если label равен 0, то выполнится первая часть кода (fetchUsers). Если label равен 1, то выполнится вторая часть кода (println). Это позволяет отделить вызов fetchUsers от вызова println.

Первый вызов метода invokeSuspend происходит при запуске корутины. В этом вызове будет выполнена первая часть кода (в случае label, равного 0), а затем будет запущена suspend-функция. После завершения работы suspend-функции необходимо сделать второй вызов метода invokeSuspend, чтобы выполнить вторую часть кода, то есть вызов println.

Однако перед вторым вызовом invokeSuspend необходимо изменить значение переменной label с 0 на 1. Это можно сделать в первой части кода перед вызовом suspend-функции.

Так мы рассмотрели основные концепции, связанные с suspend-функциями и Continuation.

## Q8. Что такое Dispatchers?

По аналогии с Schedulers в RxJava для управления потоками выполнения операций в Kotlin Coroutines используются так называемые Dispatchers. Dispatchers позволяют указывать, на каком потоке должна выполняться каждая корутина. Kotlin предоставляет несколько встроенных диспетчеров, а также позволяет создавать свои собственные диспетчеры. Рассмотрим более подробно, как работают Dispatchers и как они используются в мобильной разработке.

Существует несколько встроенных диспетчеров, доступных в Kotlin.

**Dispatchers.Main** — это диспетчер, который используется для выполнения корутин в главном потоке Android. Он должен применяться для всех операций, которые изменяют пользовательский интерфейс, таких как обновление View, Toast и т.д.

**Dispatchers.IO** — диспетчер, который используется для ввода-вывода (I/O) операций, таких как чтение или запись файлов, сетевые операции и т.д. Он также имеет доступ к пулу потоков с несколькими потоками.

**Dispatchers.Default** — это диспетчер, который используется по умолчанию. Он предназначен для выполнения вычислительных задач и имеет доступ к пулу потоков с несколькими потоками. Если вы не указываете явно диспетчер для корутины, она будет выполнена на диспетчере Default.

**Dispatchers.Unconfined** — это диспетчер, который не ограничивает выполнение корутины каким-либо конкретным потоком. Корутина будет продолжена на том же потоке, на котором была запущена. Этот диспетчер должен использоваться только в очень ограниченном числе случаев, когда корутина может быть запущена и продолжена на любом потоке.
